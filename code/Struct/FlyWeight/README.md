# 轻量模式

尽量共享实例避免new出实例

意图：
	运用共享技术有效地支持大量细粒度的对象。

主要解决：
	在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

何时使用： 
	1、系统中有大量对象。 
	2、这些对象消耗大量内存。 
	3、这些对象的状态大部分可以外部化。 
	4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 
	5、系统不依赖于这些对象身份，这些对象是不可分辨的。

如何解决：
	用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

关键代码：
	用 HashMap 存储这些对象。

应用实例： 
	1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 
	2、数据库的数据池。

优点：
	大大减少对象的创建，降低系统的内存，使效率提高。

缺点：
	提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，随着内部状态的变化而变化，否则会造成系统的混乱。
	

使用场景： 
	1、系统有大量相似对象。 
	2、需要缓冲池的场景。

注意事项： 
	1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 
	2、这些类必须有一个工厂对象加以控制。
	3、内蕴状态存储在享元内部属于成员属性并且可以共享，不会随环境的改变而有所不同。
	4、外蕴状态是随环境的改变而改变的，不可以共享。外蕴状态不能影响内蕴状态，它们是相互独立的。
	   将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。
    5、亨元对象的外蕴状态必须由客户端保存，并在亨元对象被创建之后，在需要使用的时候再传入到亨元对象内部。
	6、享元模式的内部状态，通常指的是包含在享元对象内部的、对象本身的状态，通常是独立于使用享元的场景的信息，一般创建过后就不再变化的状态，  因此可以共享。
	7、外部状态指的是享元对象之外的状态，取决于使用享元的场景，会根据使用场景而变化，因此不可共享。如果享元对象需要这些外部状态的话，可以从  外部  传递到享元对象里面，比如通过方法的参数来传递。
	8、享元模式真正缓存和共享的数据是享元的内部状态，而外部状态是不应该被缓存共享的。
	9、内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态。
